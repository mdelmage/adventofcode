#!/usr/bin/env python
# -*- coding: utf-8 -*-

def next_secret(secret):
    # In particular, each buyer's secret number evolves into the next secret number
    # in the sequence via the following process:
    # 
    # Calculate the result of multiplying the secret number by 64. Then, mix this result into the secret number.
    # Finally, prune the secret number.
    secret = ((secret * 64) ^ secret) % 16777216

    # Calculate the result of dividing the secret number by 32. Round the result down to the nearest integer.
    # Then, mix this result into the secret number. Finally, prune the secret number.
    secret = ((secret //32) ^ secret) % 16777216

    # Calculate the result of multiplying the secret number by 2048. Then, mix this result into the secret number.
    # Finally, prune the secret number.
    secret = ((secret * 2048) ^ secret) % 16777216

    return secret

# Parse the secret numbers of each buyer.
with open('day22_input.txt') as f:
    buyer_secrets = [int(line.rstrip('\n')) for line in f]

# For each buyer, simulate the creation of 2000 new secret numbers.
# What is the sum of the 2000th secret number generated by each buyer?
secrets_sum = 0
for secret in buyer_secrets:
    for i in range(2000):
        secret = next_secret(secret)
    secrets_sum += secret

print('Part One: Sum of 2000th secret number for each buyer is {0}.'.format(secrets_sum))

# Unfortunately, the monkey only knows how to decide when to sell by looking at the changes in price.
# Specifically, the monkey will only look for a specific sequence of four consecutive changes in price,
# then immediately sell when it sees that sequence.
#
# Let's build a history of 4-price-change tuples and record how many bananas we'd get
# if every buyer sold when they saw that sequence.
price_changes = {}

for secret in buyer_secrets:
    price_changes_local = {}
    price_history = []
    for step in range(2000):
        s_next = next_secret(secret)
        # Of course, the secret numbers aren't the prices each buyer is offering! That would be ridiculous.
        # Instead, the prices the buyer offers are just the ones digit of each of their secret numbers.
        price = secret % 10
        price_next = s_next % 10
        secret = s_next

        # Keep a rolling history of the last 4 price changes we've seen.
        price_history = price_history[-3:] + [price_next - price]
        price_history_tuple = tuple(price_history)

        # Ignore the first few iterations, when the history hasn't been built up yet.
        if len(price_history_tuple) == 4:
            # We only care about the first time we see a particular 4-price-change sequence.
            if price_history_tuple not in price_changes_local: price_changes_local[price_history_tuple] = price_next

    # Add the bananas we got for each sequence to the global total.
    for seq in price_changes_local:
        price_changes[seq] = price_changes.get(seq, 0) + price_changes_local[seq]

# Find the most profitable 4-price-change sequence.
most_bananas = 0
for seq in price_changes:
    if price_changes[seq] > most_bananas: most_bananas = price_changes[seq]

# Figure out the best sequence to tell the monkey so that by looking for that same sequence of changes
# in every buyer's future prices, you get the most bananas in total. What is the most bananas you can get?
print('Part Two: The most bananas you can get is {0}.'.format(most_bananas))